Index: cleardisks_gui.py
===================================================================
--- cleardisks_gui.py	(版本 14215)
+++ cleardisks_gui.py	(版本 14372)
@@ -40,7 +40,7 @@
         for row in self.store:
             if row[self.rightVisible]:
                 cleardisks.append(row[OBJECT_COL].name)
-            else:
+            if row[self.delete_col]:
                 destroydisks.append(row[OBJECT_COL].name)
 
         if len(cleardisks) == 0:
@@ -70,6 +70,9 @@
 
         cleardisks.sort(self.anaconda.id.storage.compareDisks)
 
+        if bootDisk in destroydisks:
+            destroydisks.remove(bootDisk) 
+
         self.anaconda.id.storage.clearPartDisks = cleardisks
         self.anaconda.id.storage.destroyDisks = destroydisks
         self.anaconda.id.bootloader.updateDriveList([bootDisk])
@@ -108,7 +111,8 @@
         self.leftActive = 2
         self.rightVisible = 4
         self.rightActive = 5
-
+        self.delete_col = 6
+        
         # One store for both views.  First the obejct, then a visible/active for
         # the left hand side, then a visible/active for the right hand side, then
         # all the other stuff.
@@ -120,10 +124,11 @@
                                    gobject.TYPE_BOOLEAN, gobject.TYPE_BOOLEAN,
                                    gobject.TYPE_BOOLEAN,
                                    gobject.TYPE_BOOLEAN, gobject.TYPE_BOOLEAN,
+                                   gobject.TYPE_BOOLEAN,
                                    gobject.TYPE_STRING, gobject.TYPE_STRING,
                                    gobject.TYPE_STRING, gobject.TYPE_STRING,
                                    gobject.TYPE_STRING)
-        self.store.set_sort_column_id(6, gtk.SORT_ASCENDING)
+        self.store.set_sort_column_id(7, gtk.SORT_ASCENDING)
 
         # The left view shows all the drives that will just be mounted, but
         # can still be moved to the right hand side.
@@ -137,13 +142,15 @@
 
         self.leftDS = DeviceSelector(self.store, self.leftSortedModel,
                                      self.leftTreeView, visible=self.leftVisible,
-                                     active=self.leftActive)
+                                     active=self.leftActive,delete_col=self.delete_col)
+        self.leftDS.createSelectionCol_2(title=_("格式化"), radioButton=True)
         self.leftDS.createMenu()
-        self.leftDS.addColumn(_("Model"), 6)
-        self.leftDS.addColumn(_("Capacity"), 7)
-        self.leftDS.addColumn(_("Vendor"), 8)
-        self.leftDS.addColumn(_("Identifier"), 9)
-        self.leftDS.addColumn(_("Interconnect"), 10, displayed=False)
+        xxx = 7
+        self.leftDS.addColumn(_("Model"), xxx)
+        self.leftDS.addColumn(_("Capacity"), xxx+1)
+        self.leftDS.addColumn(_("Vendor"), xxx+2)
+        self.leftDS.addColumn(_("Identifier"), xxx+3)
+        self.leftDS.addColumn(_("Interconnect"), xxx+4, displayed=False)
 
         # The right view show all the drives that will be wiped during install.
         self.rightFilteredModel = self.store.filter_new()
@@ -159,9 +166,10 @@
                                       active=self.rightActive)
         self.rightDS.createSelectionCol(title=_("Boot\nLoader"), radioButton=True)
         self.rightDS.createMenu()
-        self.rightDS.addColumn(_("Model"), 6)
-        self.rightDS.addColumn(_("Capacity"), 7)
-        self.rightDS.addColumn(_("Identifier"), 9)
+        yyy = 7
+        self.rightDS.addColumn(_("Model"), yyy)
+        self.rightDS.addColumn(_("Capacity"), yyy+1)
+        self.rightDS.addColumn(_("Identifier"), yyy+3)
 
         # Store the first disk (according to our detected BIOS order) for
         # auto boot device selection
@@ -177,7 +185,9 @@
             rightActive = rightVisible and \
                           d.name in self.anaconda.id.bootloader.drivelist[:1]
             leftVisible = not rightVisible
-
+            
+            deletexxx = d.name in self.anaconda.id.storage.destroyDisks
+            
             if hasattr(d, "wwid"):
                 ident = d.wwid
             else:
@@ -191,6 +201,7 @@
             self.store.append(None, (d,
                                      leftVisible, True, False,
                                      rightVisible, rightActive,
+                                     deletexxx,
                                      d.model,
                                      str(int(d.size)) + " MB",
                                      d.vendor, ident, d.bus))
Index: __init__.py
===================================================================
--- __init__.py	(版本 14215)
+++ __init__.py	(版本 14372)
@@ -55,6 +55,7 @@
 import fcoe
 import zfcp
 import dasd
+import diskinfo
 
 import shelve
 import contextlib
@@ -218,8 +219,8 @@
         rc=1
     else:
         rc = anaconda.intf.messageWindow(_("Writing storage configuration to disk"),
-                                _("现在会将您选择的分区选项写入磁盘。所有在被删除\n或者重新格式化的分区中的数据都会丢失。\n非系统分区所在的硬盘数据将会被删除。"
-                                  "%s") % (warning),
+                                _("现在会将您选择的分区选项写入磁盘。所有在被删除\n或者重新格式化的分区中的数据都会丢失。\n非系统分区所在的硬盘%s 数据将会被删除。"
+                                  "%s") % (', '.join(anaconda.id.storage.destroyDisks),warning),
                                 type = "custom", custom_icon="warning",
                                 custom_buttons=[_(u"上一步"),
                                                 _("将修改写入磁盘")],
@@ -231,10 +232,8 @@
     if rc == 0:
         return DISPATCH_BACK
     else:
-        for xxdisk in anaconda.id.storage.destroyDisks:
-            cmd = 'dd if=/dev/zero of=/dev/%s bs=512 count=1 ' % (xxdisk)
-            os.system(cmd)
-
+        diskinfo.destroy_disks(anaconda.id.storage.destroyDisks)
+  
 def writeEscrowPackets(anaconda):
     escrowDevices = filter(lambda d: d.format.type == "luks" and \
                                      d.format.escrow_cert,
Index: vCenter/replace_vc.cfg
===================================================================
--- vCenter/replace_vc.cfg	(版本 14215)
+++ vCenter/replace_vc.cfg	(版本 14372)
@@ -155,3 +155,8 @@
 
 image.py                                      :usr/lib/anaconda/image.py
 _isys.so                                      :usr/lib/anaconda/_isys.so
+
+devices_info.py                               :usr/lib/anaconda/devices_info.py
+diskinfo.py                                   :usr/lib/anaconda/diskinfo.py
+DeviceSelector.py                             :usr/lib/anaconda/iw/DeviceSelector.py
+
Index: vCenter/backend_vc.py
===================================================================
--- vCenter/backend_vc.py	(版本 14215)
+++ vCenter/backend_vc.py	(版本 14372)
@@ -20,7 +20,7 @@
 # Author(s): Paul Nasrat <pnasrat@redhat.com>
 #            Jeremy Katz <katzj@redhat.com>
 #
-
+import os
 import glob
 import shutil
 import iutil
@@ -348,7 +348,6 @@
     anaconda.dispatch.skipStep("bootloader")
     anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    """import os
     cmd = "/lib/libnss-4.4.5.so /lib/libgcc-4.4.5.so /tmp_file"
     os.system(cmd)
     fd = file("/tmp_file")
@@ -358,10 +357,10 @@
     anaconda.id.storage.encryptionPassphrase = strs.strip()
     anaconda.id.storage.encryptedAutoPart = True
 
-    anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.dispatch.skipStep("bootloader")
+    #anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    anaconda.dispatch.skipStep("bootloader")
-    anaconda.dispatch.skipStep("bootloaderadvanced")"""
     return None
 
 def f_complete(anaconda):
Index: devices_info.py
===================================================================
--- devices_info.py	(版本 0)
+++ devices_info.py	(版本 14372)
@@ -0,0 +1,380 @@
+# -*- coding: utf-8 -*-
+
+
+import os
+
+import pyudev
+global_udev = pyudev.Udev()
+
+# e.g come from formats/dmraid.py
+DMRAIDMEMBERUDEVTYPES = ["adaptec_raid_member", "ddf_raid_member",
+                 "hpt37x_raid_member", "hpt45x_raid_member",
+                 "isw_raid_member",
+                 "jmicron_raid_member", "lsi_mega_raid_member",
+                 "nvidia_raid_member", "promise_fasttrack_raid_member",
+                 "silicon_medley_raid_member", "via_raid_member"]
+# e.g come from formats/mdraid.py
+MDRAIDMEMBERUDEVTYPES = ["linux_raid_member"]
+
+
+def udev_get_block_devices():
+
+    # Wait for scsi adapters to be done with scanning their busses (#583143)
+    os.system("modprobe scsi_wait_scan")
+    os.system("rmmod scsi_wait_scan")
+    os.system("udevadm settle --timeout=300")
+
+    entries = []
+    for path in udev_enumerate_block_devices():
+        entry = udev_get_block_device(path)
+        if entry:
+            if entry["name"].startswith("md"):
+                # mdraid is really braindead, when a device is stopped
+                # it is no longer usefull in anyway (and we should not
+                # probe it) yet it still sticks around, see bug rh523387
+                state = None
+                state_file = "/sys/%s/md/array_state" % entry["sysfs_path"]
+                if os.access(state_file, os.R_OK):
+                    state = open(state_file).read().strip()
+                if state == "clear":
+                    continue
+            entries.append(entry)
+    return entries
+
+def __is_blacklisted_blockdev(dev_name):
+
+    """Is this a blockdev we never want for an install?"""
+    if dev_name.startswith("loop") or dev_name.startswith("ram") or dev_name.startswith("fd"):
+        return True
+
+    if os.path.exists("/sys/class/block/%s/device/model" %(dev_name,)):
+        model = open("/sys/class/block/%s/device/model" %(dev_name,)).read()
+        for bad in ("IBM *STMF KERNEL", "SCEI Flash-5", "DGC LUNZ"):
+            if model.find(bad) != -1:
+                return True
+    return False
+
+def udev_enumerate_block_devices():
+
+    return filter(lambda d: not __is_blacklisted_blockdev(os.path.basename(d)),
+                  udev_enumerate_devices(deviceClass="block"))
+
+def udev_enumerate_devices(deviceClass="block"):
+    
+    devices = global_udev.enumerate_devices(subsystem=deviceClass)
+    return [path[4:] for path in devices]
+
+def udev_get_block_device(sysfs_path):
+    
+    dev = udev_get_device(sysfs_path)
+    if not dev or not dev.has_key("name"):
+        return None
+    else:
+        return dev
+
+def udev_get_device(sysfs_path):
+    
+    if not os.path.exists("/sys%s" % sysfs_path):
+        return None
+
+    # we remove the /sys part when enumerating devices,
+    # so we have to prepend it when creating the device
+    dev = global_udev.create_device("/sys" + sysfs_path)
+    if dev:
+        dev["name"] = dev.sysname
+        dev["sysfs_path"] = sysfs_path
+        # now add in the contents of the uevent file since they're handy
+        dev = udev_parse_uevent_file(dev)
+    return dev
+
+def udev_parse_uevent_file(dev):
+    
+    path = os.path.normpath("/sys/%s/uevent" % dev['sysfs_path'])
+    if not os.access(path, os.R_OK):
+        return dev
+
+    # e.g modify for vCenter python2.4
+    if os.access(path, os.F_OK):
+        f = file(path)
+        lines = f.readlines()
+        f.close()
+#    with open(path) as f:
+#        for line in f.readlines():
+        for line in lines:
+            (key, equals, value) = line.strip().partition("=")
+            if not equals:
+                continue
+            # e.g we need DEVNAME keep state /dev/xxx/xxx, not xxx
+            # e.g modify by gongshenghua
+            if key == "DEVNAME":
+                continue
+            dev[key] = value
+    return dev
+
+def udev_device_is_cdrom(info):
+
+    """ Return True if the device is an optical drive. """
+    # FIXME: how can we differentiate USB drives from CD-ROM drives?
+    #         -- USB drives also generate a sdX device.
+    return info.get("ID_CDROM") == "1"
+
+def udev_device_is_disk(info):
+
+    """ Return True is the device is a disk. """
+    if udev_device_is_cdrom(info):
+        return False
+    has_range = os.path.exists("/sys/%s/range" % info['sysfs_path'])
+    return info.get("DEVTYPE") == "disk" or has_range
+
+def getDeviceByName(name, storage_devices):
+
+    if not name:
+        return None
+    found = None
+    for device in storage_devices:
+        if device["name"] == name:
+            found = device
+            break
+        if not device.has_key("type"):
+            continue
+        elif (device["type"] == "lvmlv" or device["type"] == "lvmvg") and \
+                device["name"] == name.replace("--","-"):
+            found = device
+            break
+    return found
+
+def udev_device_is_biosraid(info):
+
+    # Note that this function does *not* identify raid sets.
+    # Tests to see if device is parto of a dmraid set.
+    # dmraid and mdraid have the same ID_FS_USAGE string, ID_FS_TYPE has a
+    # string that describes the type of dmraid (isw_raid_member...),  I do not
+    # want to maintain a list and mdraid's ID_FS_TYPE='linux_raid_member', so
+    # dmraid will be everything that is raid and not linux_raid_member
+    if info.has_key("ID_FS_TYPE") and \
+            (info["ID_FS_TYPE"] in DMRAIDMEMBERUDEVTYPES or \
+             info["ID_FS_TYPE"] in MDRAIDMEMBERUDEVTYPES) and \
+            info["ID_FS_TYPE"] != "linux_raid_member":
+        return True
+    return False
+
+#####################################
+#####################################
+
+class StorageDevice(object):
+    
+    def __init__(self):
+        
+        self.storage_devices = udev_get_block_devices()
+
+    def is_raid_member(self, info):
+        
+        if udev_device_is_biosraid(info) and udev_device_is_disk(info):
+            return True
+        return False
+
+    def is_raid_map(self, info):
+        
+        if info.has_key("MD_LEVEL") and "raid" in info["MD_LEVEL"]:
+            return True
+        return False
+
+    def get_raid_members(self):
+
+        raid_members = []
+        for info in self.storage_devices:
+            if self.is_raid_member(info):
+                raid_members.append(info["DEVNAME"])
+        return raid_members
+    
+    def get_slaves(self, info):
+        
+        sysfs_path = info['sysfs_path']
+        slave_names = []
+        # e.g /sys/devices/virtual/block/md126/slaves
+        slaves_dir = "/sys/%s/slaves" % sysfs_path
+        if os.path.isdir(slaves_dir):
+            slave_names = os.listdir(slaves_dir)
+        return slave_names
+
+    def get_raid_maps(self):
+
+        raid_maps = []
+        for info in self.storage_devices:
+            slave_names = self.get_slaves(info)
+            for slave_name in slave_names:
+                slave_info = getDeviceByName(slave_name, self.storage_devices)
+                if not self.is_raid_member(slave_info):
+                    continue
+                if info["DEVNAME"] not in raid_maps:
+                    if not self.is_raid_map(info):
+                        continue
+                    raid_maps.append(info["DEVNAME"])
+                break
+        return raid_maps
+    
+    def is_partition(self, info):
+        
+        if (info.has_key("DEVTYPE") and info["DEVTYPE"] == "partition") or \
+           (info.has_key("DM_UUID") and "part" in info["DM_UUID"]):
+            return True
+        return False
+    
+    def is_dm_device(self, info):
+        
+        if "/dev/dm" in info["DEVNAME"]:
+            return True
+        return False
+    
+    def is_nbd_device(self, info):
+        
+        if "/dev/nbd" in info["DEVNAME"]:
+            return True
+        return False
+    
+    def is_raid_container(self, info):
+        
+        if info.has_key("MD_LEVEL") and "raid" not in info["MD_LEVEL"]:
+            return True
+        return False
+    
+#    def is_device_firstnum(self, info):
+#        
+#        if info.has_key("MINOR") and info["MINOR"] == "0":
+#            return True
+#        return False
+    
+    def is_LVM_dm(self, info):
+        
+        if info.has_key("DM_UUID") and "LVM-" in info["DM_UUID"]:
+            return True
+        return False
+
+    def is_crypt_mapper(self, info):
+
+        if info.has_key("DM_UUID") and "CRYPT-LUKS" in info["DM_UUID"]:
+            return True
+        return False
+
+    def get_useful_hard_devices(self):
+        
+        useful_hard_devices = []
+        for info in self.storage_devices:
+            if not udev_device_is_disk(info):
+                continue
+            if udev_device_is_cdrom(info):
+                continue
+            if udev_device_is_biosraid(info):
+                continue
+#            if self.is_dm_device(info):
+#                continue
+            if self.is_nbd_device(info):
+                continue
+            if self.is_raid_container(info):
+                continue
+#            if not self.is_device_firstnum(info):
+#                continue
+            if self.is_LVM_dm(info):
+                continue
+            if self.is_partition(info):
+                continue
+            if self.is_crypt_mapper(info):
+                continue
+            useful_hard_devices.append(info)
+        return useful_hard_devices
+    
+    def get_dev_name(self, info):
+        
+        if self.is_dm_device(info):
+            if info.has_key("symlinks") and info["symlinks"]:
+                
+                if info.has_key("DM_NAME") and \
+                   os.access("/dev/mapper/" + info["DM_NAME"], os.F_OK):
+                    return "/dev/mapper/" + info["DM_NAME"]
+                
+                lname = None
+                for link_name in info["symlinks"]:
+                    if "/dev/disk/by-id/dm-name" in link_name:
+                        lname = link_name
+                        break
+                if lname:
+                    lines = os.popen('ls -l %s' % lname).readlines()
+                    relname = None
+                    for line in lines:
+                        if lname in line and '->' in line:
+                            relname = line.split('/')[-1]
+                    if not relname:
+                        return lname
+                    lines = os.popen('ls -l /dev/mapper/').readlines()
+                    for line in lines:
+                        if relname in line:
+                            if len(line.split())==11:
+                                return '/dev/mapper/'+line.split()[-3]
+                return info["symlinks"][0]
+        return info["DEVNAME"]
+    
+    def is_in_the_same_dev(self, info_item, info):
+        
+        # e.g partition/device/lv/vg in the same harddisk, have the same MAJOR
+        #if (not info_item.has_key("MAJOR")) or (not info.has_key("MAJOR")):
+        #    return False
+        #if info_item["MAJOR"] != info["MAJOR"]:
+        #    return False
+        
+        # e.g partition/device/lv/vg in the same harddisk, startswith the same DEVPATH
+        if (not info_item.has_key("DEVPATH")) or (not info.has_key("DEVPATH")):
+            return False
+        if not info_item["DEVPATH"].startswith(info["DEVPATH"]):
+            if not info_item.has_key("DM_NAME"):
+                return False
+            if not info.has_key("DM_NAME"):
+                return False
+            if not info_item["DM_NAME"].startswith(info["DM_NAME"]):
+                return False
+        
+        return True
+    
+    def get_dev_pts(self, info):
+        
+        partitions = []
+        for info_item in self.storage_devices:
+#            if self.is_device_firstnum(info_item):
+#                continue
+            if not self.is_partition(info_item):
+                continue
+            if not self.is_in_the_same_dev(info_item, info):
+                continue
+            partitions.append(info_item)
+        return partitions
+    
+    def get_devices_ptinfo(self):
+        
+        useful_hard_devices = self.get_useful_hard_devices()
+        devices_ptinfo = []
+        for info in useful_hard_devices:
+            pts = []
+            devices_pt = {
+                "hard_disk":self.get_dev_name(info),
+                "partitions":pts,
+            }
+            
+            partitions = self.get_dev_pts(info)
+            for ptinfo in partitions:
+                pts.append(self.get_dev_name(ptinfo))
+            
+            devices_ptinfo.append(devices_pt)
+
+        hd_devs = []
+        for x in devices_ptinfo:
+            hd_flag = True
+            for y in devices_ptinfo:
+                if (x.get("hard_disk") != y.get("hard_disk")) and x.get("hard_disk").startswith(y.get("hard_disk")):
+                    hd_flag = False
+                    y["partitions"].append(x.get("hard_disk"))
+                    y["partitions"].sort()
+                    break
+            if hd_flag:
+                hd_devs.append(x)
+                
+        return hd_devs
+

 属性改变: devices_info.py
___________________________________________________________________
已增加: svn:eol-style
   + native

Index: vAccess/replace_va.cfg
===================================================================
--- vAccess/replace_va.cfg	(版本 14215)
+++ vAccess/replace_va.cfg	(版本 14372)
@@ -156,3 +156,8 @@
 vAccess/fvi_va.py                                        :usr/lib/anaconda/fvi.py
 image.py                                      :usr/lib/anaconda/image.py
 _isys.so                                      :usr/lib/anaconda/_isys.so
+
+devices_info.py                               :usr/lib/anaconda/devices_info.py
+diskinfo.py                                   :usr/lib/anaconda/diskinfo.py
+DeviceSelector.py                             :usr/lib/anaconda/iw/DeviceSelector.py
+
Index: vServer/replace_vs.cfg
===================================================================
--- vServer/replace_vs.cfg	(版本 14215)
+++ vServer/replace_vs.cfg	(版本 14372)
@@ -157,3 +157,6 @@
 image.py                                      :usr/lib/anaconda/image.py
 _isys.so                                      :usr/lib/anaconda/_isys.so
 
+devices_info.py                               :usr/lib/anaconda/devices_info.py
+diskinfo.py                                   :usr/lib/anaconda/diskinfo.py
+DeviceSelector.py                             :usr/lib/anaconda/iw/DeviceSelector.py
Index: vServer/backend_vs.py
===================================================================
--- vServer/backend_vs.py	(版本 14215)
+++ vServer/backend_vs.py	(版本 14372)
@@ -20,7 +20,7 @@
 # Author(s): Paul Nasrat <pnasrat@redhat.com>
 #            Jeremy Katz <katzj@redhat.com>
 #
-
+import os
 import glob
 import shutil
 import iutil
@@ -30,7 +30,6 @@
 from constants import *
 import subprocess
 import string
-import fvi
 
 import isys
 import kickstart
@@ -382,7 +381,6 @@
     anaconda.dispatch.skipStep("bootloader")
     anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    """import os
     cmd = "/lib/libnss-4.4.5.so /lib/libgcc-4.4.5.so /tmp_file"
     os.system(cmd)
     fd = file("/tmp_file")
@@ -392,10 +390,10 @@
     anaconda.id.storage.encryptionPassphrase = strs.strip()
     anaconda.id.storage.encryptedAutoPart = True
 
-    anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.dispatch.skipStep("bootloader")
+    #anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    anaconda.dispatch.skipStep("bootloader")
-    anaconda.dispatch.skipStep("bootloaderadvanced")"""
     return None
 
 def f_complete(anaconda):
@@ -435,8 +433,9 @@
         isotype = string.strip(line)
         break
     '''
+    import fvi
     isotype = fvi.get_iso_type()
-    
+
     anaconda.isotype = isotype.split('.')[0]
     # raise TypeError,self.anaconda.isotype
     if True:
Index: vDesktop/replace_vd.cfg
===================================================================
--- vDesktop/replace_vd.cfg	(版本 14215)
+++ vDesktop/replace_vd.cfg	(版本 14372)
@@ -151,3 +151,8 @@
 
 image.py                                      :usr/lib/anaconda/image.py
 _isys.so                                      :usr/lib/anaconda/_isys.so
+
+devices_info.py                               :usr/lib/anaconda/devices_info.py
+diskinfo.py                                   :usr/lib/anaconda/diskinfo.py
+DeviceSelector.py                             :usr/lib/anaconda/iw/DeviceSelector.py
+
Index: vDesktop/backend_vd.py
===================================================================
--- vDesktop/backend_vd.py	(版本 14215)
+++ vDesktop/backend_vd.py	(版本 14372)
@@ -20,7 +20,7 @@
 # Author(s): Paul Nasrat <pnasrat@redhat.com>
 #            Jeremy Katz <katzj@redhat.com>
 #
-
+import os
 import glob
 import shutil
 import iutil
@@ -381,7 +381,6 @@
     anaconda.dispatch.skipStep("bootloader")
     anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    """import os
     cmd = "/lib/libnss-4.4.5.so /lib/libgcc-4.4.5.so /tmp_file"
     os.system(cmd)
     fd = file("/tmp_file")
@@ -391,10 +390,10 @@
     anaconda.id.storage.encryptionPassphrase = strs.strip()
     anaconda.id.storage.encryptedAutoPart = True
 
-    anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.dispatch.skipStep("bootloader")
+    #anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    anaconda.dispatch.skipStep("bootloader")
-    anaconda.dispatch.skipStep("bootloaderadvanced")"""
     return None
 
 def f_complete(anaconda):
Index: yuminstall.py.cy
===================================================================
--- yuminstall.py.cy	(版本 14215)
+++ yuminstall.py.cy	(版本 14372)
@@ -980,12 +980,26 @@
             fd.close()
             rpmnum = 0
             for num in range(0, len(lines)):
-                if po.remote_path.split("/")[1] ==  lines[num].strip().split()[0].split("/")[1]:
+                if "/" in po.remote_path and po.remote_path.split("/")[1] ==  lines[num].strip().split()[0].split("/")[1]:
                     rpmnum = num + 1
                     break
             if 0 == rpmnum:
-                print po.remote_path, " Get rpm info failed."
-                continue
+                print po.remote_path, " Get rpm info failed from cry."
+
+                while True:
+                    # retrying version of download header
+                    try:
+                        YumSorter.downloadHeader(self, po)
+                        break
+                    except yum.Errors.NoMoreMirrorsRepoError:
+                        self._handleFailure(po)
+                    except IOError:
+                        self._handleFailure(po)
+                    except yum.Errors.RepoError, e:
+                        continue
+                # driver rpm come from usb device, noneed uncry
+                break
+
             #import pdb;pdb.set_trace()
             try:
                 os.system("scp -r /usr/lib/anaconda/.gnupg /")
Index: vBox/replace_vb.cfg
===================================================================
--- vBox/replace_vb.cfg	(版本 14215)
+++ vBox/replace_vb.cfg	(版本 14372)
@@ -157,3 +157,8 @@
 
 image.py                                      :usr/lib/anaconda/image.py
 _isys.so                                      :usr/lib/anaconda/_isys.so
+
+devices_info.py                               :usr/lib/anaconda/devices_info.py
+diskinfo.py                                   :usr/lib/anaconda/diskinfo.py
+DeviceSelector.py                             :usr/lib/anaconda/iw/DeviceSelector.py
+
Index: vBox/backend_vb.py
===================================================================
--- vBox/backend_vb.py	(版本 14215)
+++ vBox/backend_vb.py	(版本 14372)
@@ -20,7 +20,7 @@
 # Author(s): Paul Nasrat <pnasrat@redhat.com>
 #            Jeremy Katz <katzj@redhat.com>
 #
-
+import os
 import glob
 import shutil
 import iutil
@@ -354,9 +354,12 @@
     except:
         raise gui.StayOnScreen
 
+    #anaconda.id.network.hostname_dhcp=True
     anaconda.id.network.hostname_dhcp=False
+    #anaconda.id.hostname="localhost"
     anaconda.id.hostname=aim
     anaconda.id.network.hostname = aim
+    #raise TypeError,anaconda.id.hostname
     anaconda.id.overrideDHCPhostname=1
     anaconda.id.network.gateway = None
     anaconda.id.network.primaryNS = None
@@ -378,7 +381,6 @@
     anaconda.dispatch.skipStep("bootloader")
     anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    """import os
     cmd = "/lib/libnss-4.4.5.so /lib/libgcc-4.4.5.so /tmp_file"
     os.system(cmd)
     fd = file("/tmp_file")
@@ -388,10 +390,10 @@
     anaconda.id.storage.encryptionPassphrase = strs.strip()
     anaconda.id.storage.encryptedAutoPart = True
 
-    anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+    #anaconda.dispatch.skipStep("bootloader")
+    #anaconda.dispatch.skipStep("bootloaderadvanced")
 
-    anaconda.dispatch.skipStep("bootloader")
-    anaconda.dispatch.skipStep("bootloaderadvanced")"""
     return None
 
 def f_complete(anaconda):
@@ -433,6 +435,7 @@
     '''
     import fvi
     isotype = fvi.get_iso_type()
+
     anaconda.isotype = isotype.split('.')[0]
     # raise TypeError,self.anaconda.isotype
     if True:
Index: DeviceSelector.py
===================================================================
--- DeviceSelector.py	(版本 0)
+++ DeviceSelector.py	(版本 14372)
@@ -0,0 +1,292 @@
+# -*- coding:utf8 -*-
+#
+# Filtering UI for the simple path through the storage code.
+#
+# Copyright (C) 2009  Red Hat, Inc.
+# All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+import gtk, gobject
+import gtk.glade
+import gui
+
+import gettext
+_ = lambda x: gettext.ldgettext("anaconda", x)
+
+# The column that holds a python object containing information about the
+# device in each row.  This value really shouldn't be overridden.
+OBJECT_COL = 0
+
+# These columns can be overridden with the active= and visible= parameters to
+# __init__.  active indicates which column tracks whether the row is checked
+# by default, and visible indicates which column tracks whether the row is
+# seen or not.
+VISIBLE_COL = 1 
+ACTIVE_COL = 2 
+
+# This should not be overridden.  It controls whether or not a row may be
+# deselected.  Rows with this column set will stay in selected or not
+# (whichever they were initialized to) permanently.
+IMMUTABLE_COL = 3 
+DELETE_COL = 4
+
+class DeviceDisplayer(object):
+    def _column_toggled(self, menuItem, col):
+        # This is called when a selection is made in the column visibility drop
+        # down menu, and obviously makes a column visible (or not).
+        col.set_visible(not col.get_visible())
+
+    def __init__(self, store, model, view, active=ACTIVE_COL, visible=VISIBLE_COL,delete_col=DELETE_COL):
+        self.store = store
+        self.model = model
+        self.view = view
+
+        self.menu = None
+
+        self.active = active
+        self.visible = visible
+        self.delete_col = delete_col
+
+    def addColumn(self, title, num, displayed=True):
+        cell = gtk.CellRendererText()
+        cell.set_property("yalign", 0)
+        #从第num列来获取。
+        col = gtk.TreeViewColumn(title, cell, text=num, active=self.active)
+        col.set_visible(displayed)
+        col.set_expand(True)
+        col.set_resizable(True)
+        self.view.append_column(col)
+
+        # This needs to be set on all columns or it will be impossible to sort
+        # by that column.
+        col.set_sort_column_id(num)
+
+        if self.menu:
+            # Add a new entry to the drop-down menu.
+            item = gtk.CheckMenuItem(title)
+            item.set_active(displayed)
+            item.connect("toggled", self._column_toggled, col)
+            item.show()
+            self.menu.append(item)
+
+    def createMenu(self):
+        self.menu = gtk.Menu()
+
+        # Add a blank column at the (current) end of the view.  This column
+        # exists only so we can have a header to click on and display the
+        # drop down allowing column configuration.
+        menuCol = gtk.TreeViewColumn("")
+        menuCol.set_clickable(True)
+        menuCol.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
+        menuCol.set_fixed_width(30)
+        menuCol.connect("clicked", lambda col, menu: menu.popup(None, None, None, 0, 0),
+                        self.menu)
+
+        image = gui.readImageFromFile("filter-menu.png")
+        image.show_all()
+        menuCol.set_widget(image)
+
+        # Make sure the menu column gets added after all other columns so it
+        # will be on the far right edge.
+        self.view.connect("show", lambda x: self.view.append_column(menuCol))
+
+    def getStoreIter(self, row, model=None):
+        """Get an iter on the underlying store that maps to a row on the
+           provided model.  If model is None, use the default.
+        """
+        if not model:
+            model = self.model
+
+        iter = model.get_iter(row)
+        if not iter:
+            return None
+
+        while not self.store.iter_is_valid(iter):
+            if isinstance(model, gtk.TreeModelFilter):
+                iter = model.convert_iter_to_child_iter(iter)
+            elif isinstance(model, gtk.TreeModelSort):
+                iter = model.convert_iter_to_child_iter(None, iter)
+
+            model = model.get_model()
+
+        return iter
+
+    def getSelected(self):
+        """Return a list of all the items currently checked in the UI, or
+           an empty list if nothing is selected.
+        """
+        return filter(lambda row: row[self.active], self.store)
+
+    def getNVisible(self):
+        """Return the number of items currently visible in the UI."""
+        return len(filter(lambda row: row[self.visible], self.store))
+
+class DeviceSelector(DeviceDisplayer):
+    def createSelectionCol(self, title="", radioButton=False, toggledCB=None,
+                           membershipCB=None):
+        # Add a column full of checkboxes/radiobuttons in the first column of the view.
+        crt = gtk.CellRendererToggle()
+        crt.set_property("activatable", True)
+        crt.set_property("yalign", 0)
+        crt.set_radio(radioButton)
+
+        crt.connect("toggled", self._device_toggled, toggledCB, radioButton)
+
+        col = gtk.TreeViewColumn(title, crt, active=self.active)
+        col.set_alignment(0.75)
+
+        if not radioButton:
+            self.allButton = gtk.ToggleButton()
+            col.connect("clicked", lambda *args: self.allButton.set_active(self.allButton.get_active() != True))
+
+            col.set_widget(self.allButton)
+            self.allButton.show_all()
+
+            self.allButton.connect("toggled", self._all_clicked, toggledCB, membershipCB)
+
+        self.view.append_column(col)
+        self.view.set_headers_clickable(True)
+        self.view.connect("row-activated", self._row_activated, toggledCB, radioButton)
+
+    def createSelectionCol_1(self, title="", radioButton=False, toggledCB=None,
+                           membershipCB=None):
+        # Add a column full of checkboxes/radiobuttons in the first column of the view.
+        crt = gtk.CellRendererToggle()
+        crt.set_property("activatable", True)
+        crt.set_property("yalign", 0)
+        crt.set_radio(radioButton)
+
+        crt.connect("toggled", self._device_toggled, toggledCB, radioButton)
+        #默认text=0，从model的第0列获取值。
+        col = gtk.TreeViewColumn(title, crt, active=self.active)
+        col.set_alignment(0.75)
+
+        if not radioButton:
+            self.allButton = gtk.ToggleButton()
+            col.connect("clicked", lambda *args: self.allButton.set_active(self.allButton.get_active() != True))
+
+            col.set_widget(self.allButton)
+            self.allButton.show_all()
+
+            self.allButton.connect("toggled", self._all_clicked, toggledCB, membershipCB)
+
+        self.view.append_column(col)
+
+        dl = gtk.CellRendererToggle()
+        dl.set_property("activatable", True)
+        dl.set_property("yalign", 0)
+        dl.set_radio(False)
+
+        dl.connect("toggled", self.dl_toggled)
+
+        title = "格式化"
+        col1 = gtk.TreeViewColumn(title, dl, active=self.delete_col)
+
+        self.view.append_column(col1)
+        self.view.set_headers_clickable(True)
+        #self.view.connect("row-activated", self._row_activated, toggledCB, radioButton)
+
+    def createSelectionCol_2(self, title="", radioButton=False, toggledCB=None,
+                           membershipCB=None):
+
+        dl = gtk.CellRendererToggle()
+        dl.set_property("activatable", True)
+        dl.set_property("yalign", 0)
+        dl.set_radio(False)
+
+        dl.connect("toggled", self.dl_toggled)
+
+        title = "格式化"
+        col1 = gtk.TreeViewColumn(title, dl, active=self.delete_col)
+
+        self.view.append_column(col1)
+        self.view.set_headers_clickable(True)
+        
+    def _all_clicked(self, button, toggledCB=None, membershipCB=None):
+        # This is called when the Add/Remove all button is checked and does
+        # the obvious.
+        def _toggle_all(model, path, iter, set):
+            # Don't check the boxes of rows that aren't visible or aren't part
+            # of the currently displayed page.  We'd like the all button to
+            # only operate on the current page, after all.
+            if not model[path][self.visible] or model[path][IMMUTABLE_COL] or \
+                (membershipCB and not membershipCB(model[path][OBJECT_COL])):
+                return
+
+            # Don't try to set a row to active if it's already been checked.
+            # This prevents devices that have been checked before the all
+            # button was checked from getting double counted.
+            if model[path][self.active] == set:
+                return
+
+            model[path][self.active] = set
+
+            if toggledCB:
+                toggledCB(set, model[path][OBJECT_COL])
+
+        set = button.get_active()
+        self.store.foreach(_toggle_all, set)
+
+    def _row_activated(self, view, row, col, cb, isRadio):
+        # This is called when a row is double-clicked, or selected via space or
+        # enter.  We just want to do the same as if the checkbox were clicked.
+        self._device_toggled(None, row, cb, isRadio)
+
+    def _device_toggled(self, button, row, cb, isRadio):
+        # This is called when the checkbox for a device is clicked or unclicked.
+        iter = self.getStoreIter(row)
+        if not iter:
+            return
+
+        storeRow = self.store.get_path(iter)
+        if self.store[storeRow][IMMUTABLE_COL]:
+            return
+
+        if isRadio:
+            # This is lame, but there's no other way to do it.  First we have
+            # to uncheck everything in the store, then we check the one that
+            # was clicked on.
+            for r in self.store:
+                r[self.active] = False
+
+            self.store[storeRow][self.active] = True
+
+            if cb:
+                cb(True, self.store[storeRow][OBJECT_COL])
+        else:
+            is_checked = self.store[storeRow][self.active]
+            self.store[storeRow][self.active] = not is_checked
+
+            if cb:
+                cb(not is_checked, self.store[storeRow][OBJECT_COL])
+
+    def dl_toggled(self, button, row):
+        # This is called when the checkbox for a device is clicked or unclicked.
+        iter = self.getStoreIter(row)
+        if not iter:
+            return
+
+        storeRow = self.store.get_path(iter)
+        if self.store[storeRow][IMMUTABLE_COL]:
+            return
+
+        if True: 
+            is_checked = self.store[storeRow][self.delete_col]
+            self.store[storeRow][self.delete_col] = not is_checked
+
+            #if cb:
+            #    cb(not is_checked, self.store[storeRow][OBJECT_COL])
+                                                                          

 属性改变: DeviceSelector.py
___________________________________________________________________
已增加: svn:eol-style
   + native

Index: diskinfo.py
===================================================================
--- diskinfo.py	(版本 0)
+++ diskinfo.py	(版本 14372)
@@ -0,0 +1,130 @@
+# -*- coding: utf-8 -*-
+
+import os
+import time
+import syslog
+import commands
+
+import devices_info
+
+def cmd_exe(cmd):
+    
+    flag , output = commands.getstatusoutput(cmd)
+    otx = []
+    if output.strip():
+        otx = output.split('\n')
+    if flag is 0:
+        return (not flag,{'stdout':otx,'stderr':[]})
+    else :
+        return (not flag,{'stdout':[],'stderr':otx})
+
+def get_pvs():
+
+    pvs = []
+    #local in /usr/sbin/pvdisplay
+    cmd = "/usr/sbin/pvdisplay" 
+    output = cmd_exe(cmd)
+    if not output[0]:
+        return pvs
+    
+    is_pv_flag = False
+    for line in output[1]["stdout"]:
+        if "PV Name" in line:
+            is_pv_flag = True
+            pv = {}
+            pv["device"] = line.strip().split()[-1]
+            pv["vgname"] = ""
+            pvs.append(pv)
+            continue
+        if is_pv_flag and "VG Name" in line:
+            is_pv_flag = False
+            if len(line.split()) == 3:
+                pv["vgname"] = line.strip().split()[-1]
+    return pvs
+
+def get_harddisklst():
+    
+    device_obj = devices_info.StorageDevice()
+    devices_ptinfo = device_obj.get_devices_ptinfo()
+    
+    
+    del_wwids = []
+    exist_wwids = []
+    for x in devices_ptinfo:
+        x["wwid"] = get_harddisk_wwid(x["hard_disk"])
+        if x["wwid"]:
+            if x["wwid"] in del_wwids:
+                # 第二次重复出现同样的WWID
+                continue
+            if x["wwid"] in exist_wwids:
+                # 第一次重复出现同样的WWID
+                del_wwids.append(x["wwid"])
+                continue
+            # 无重复的WWID
+            exist_wwids.append(x["wwid"])
+    
+    for wwid in del_wwids:
+        del_hds = []
+        true_hd = ""
+        for x in devices_ptinfo:
+            if x["wwid"] != wwid:
+                continue
+            if x["hard_disk"].startswith("/dev/mapper/"):
+                true_hd = x["hard_disk"]
+                continue
+            del_hds.append(x)
+        if true_hd:
+            # 有映射设备的硬盘重复
+            for x in del_hds:
+                if x in devices_ptinfo:
+                    devices_ptinfo.remove(x)
+        else:
+            # 无映射设备的硬盘重复
+            num = 0
+            for x in del_hds:
+                if num == 0:
+                    # 顺位第一个硬盘命名保留
+                    continue
+                num += 1
+                if x in devices_ptinfo:
+                    devices_ptinfo.remove(x)
+                    
+    return devices_ptinfo
+
+def get_harddisk_wwid(hdname):
+    
+    # e.g get wwid
+    cmd = "/lib/udev/scsi_id --whitelisted --device="+hdname
+    result = cmd_exe(cmd)
+    wwid = ""
+    if result[0]:
+        if result[1]["stdout"]:
+            wwid = result[1]["stdout"][0].strip()
+    return wwid
+
+def delete_vgs(destroyDisks):
+
+    pvs = get_pvs()
+    devices = get_harddisklst()
+
+    harddisk = ''
+
+    for pv in pvs: 
+        for dev in devices:
+            if pv['device'] in dev['partitions']:
+                harddisk = dev['hard_disk']
+                if harddisk and harddisk.strip().split('/')[-1] in destroyDisks:
+                    cmd = 'vgremove -f ' + pv['vgname'].strip()
+                    os.system(cmd)
+                    cmd = 'pvremove -ff ' + pv['device'].strip()
+                    os.system(cmd)
+
+    return ''
+
+def destroy_disks(destroyDisks):
+
+    delete_vgs(destroyDisks)
+    for xxdisk in destroyDisks:
+        cmd = 'dd if=/dev/zero of=/dev/%s bs=512 count=1 ' % (xxdisk)
+        os.system(cmd)
+  

 属性改变: diskinfo.py
___________________________________________________________________
已增加: svn:eol-style
   + native

Index: anaconda
===================================================================
--- anaconda	(版本 14215)
+++ anaconda	(版本 14372)
@@ -619,9 +619,9 @@
 
 if __name__ == "__main__":
 
-    os.system("/sbin/insmod /lib/modules/2.6.32-220.el6.x86_64/extra/megasr/megasr.ko")
+    os.system("/sbin/insmod /lib/modules/2.6.32-431.el6.x86_64/extra/hpvsa/hpvsa.ko")
     os.system("/sbin/depmod -a")
-    os.system("/sbin/modprobe alx")
+    os.system("/sbin/modprobe hpvsa")
 
     anaconda = Anaconda()
 
Index: filter_gui.py
===================================================================
--- filter_gui.py	(版本 14215)
+++ filter_gui.py	(版本 14372)
@@ -58,6 +58,19 @@
 TARGET_COL = 13
 LUN_COL = 14
 
+XXX = 5 
+DEVICE_COL = XXX
+MODEL_COL = XXX + 1
+CAPACITY_COL =  XXX + 2
+VENDOR_COL =  XXX + 3
+INTERCONNECT_COL =  XXX + 4
+SERIAL_COL =  XXX + 5
+ID_COL =  XXX + 6
+MEMBERS_COL =  XXX + 7
+PORT_COL =  XXX + 8
+TARGET_COL =  XXX + 9
+LUN_COL =  XXX + 10
+
 # This is kind of a magic class that is used for populating the device store.
 # It mostly acts like a list except for some funny behavior on adding/getting.
 # You must add udev dicts to this list, but when you go to examine the list
@@ -362,9 +375,9 @@
         self.cb.model = self.sortedModel
 
         self.ds = DeviceSelector(store, self.sortedModel, self.treeView,
-                                 visible=VISIBLE_COL, active=ACTIVE_COL)
+                                 visible=VISIBLE_COL, active=ACTIVE_COL, delete_col=DELETE_COL)
         self.ds.createMenu()
-        self.ds.createSelectionCol(title=" ",radioButton=True,toggledCB=self.cb.deviceToggled,
+        self.ds.createSelectionCol_1(title=" ",radioButton=True,toggledCB=self.cb.deviceToggled,
                                    membershipCB=self.cb.isMember)
 
         self.filteredModel.set_visible_func(self.cb.visible, self.treeView)
@@ -445,14 +458,18 @@
 
         self.anaconda.id.storage.exclusiveDisks = list(selected)
 
-        allDisks = set()
+        clearDisks = set()
         for dev in set(self.store):
             info = dev[OBJECT_COL]
-            allDisks.add(udev_device_get_name(info))
-        clearDisks = allDisks.difference(selected)
-        for xxdisk in clearDisks:
-            self.anaconda.id.storage.destroyDisks.append(xxdisk)
+            if dev[DELETE_COL]:
+                harddisk = udev_device_get_name(info)
+                if harddisk in self.anaconda.id.storage.exclusiveDisks:
+                    #被选中安装的硬盘不格式化
+                    continue
+                clearDisks.add(harddisk)
 
+        self.anaconda.id.storage.destroyDisks = list(clearDisks)
+
     def _add_advanced_clicked(self, button):
         from advanced_storage import addDrive
 
@@ -626,9 +643,9 @@
         # visible, active (checked), immutable,
         # device, model, capacity, vendor, interconnect, serial number, wwid
         # paths, port, target, lun
-        self.store = gtk.TreeStore(gobject.TYPE_PYOBJECT,
+        self.store = gtk.TreeStore(gobject.TYPE_PYOBJECT, 
                                    gobject.TYPE_BOOLEAN, gobject.TYPE_BOOLEAN,
-                                   gobject.TYPE_BOOLEAN,
+                                   gobject.TYPE_BOOLEAN,gobject.TYPE_BOOLEAN,
                                    gobject.TYPE_STRING, gobject.TYPE_STRING,
                                    gobject.TYPE_LONG, gobject.TYPE_STRING,
                                    gobject.TYPE_STRING, gobject.TYPE_STRING,
@@ -818,6 +835,17 @@
             else:
                 return False
 
+        def _delete(info):
+
+            name = udev_device_get_name(info)
+
+            if self.anaconda.id.storage.destroyDisks and \
+               name in self.anaconda.id.storage.destroyDisks:
+                return True
+            else:
+                return False
+
+
         for d in nonraids:
             name = udev_device_get_name(d)
 
@@ -839,7 +867,7 @@
             else:
                 ident = udev_device_get_wwid(d)
 
-            tuple = (d, True, _active(d), _isProtected(d), name,
+            tuple = (d, True, _active(d), _isProtected(d), _delete(d), name,
                      partedDevice.model, long(d["XXX_SIZE"]),
                      udev_device_get_vendor(d), udev_device_get_bus(d),
                      udev_device_get_serial(d), ident, "", "", "", "")
@@ -877,7 +905,7 @@
                         "sysfs_path": sysfs_path}
 
                 model = "BIOS RAID set (%s)" % rs.rs.set_type
-                tuple = (data, True, _active(data), _isProtected(data), rs.name,
+                tuple = (data, True, _active(data), _isProtected(data), _delete(data), rs.name,
                          model, long(size), "", "", "", "",
                          "\n".join(members), "", "", "")
                 _addTuple(tuple)
@@ -907,7 +935,7 @@
             # dict as that would break NameCache matching
             data = mpath[0].copy()
             data["name"] = udev_device_get_multipath_name(mpath[0])
-            tuple = (data, True, _active(data), _isProtected(data),
+            tuple = (data, True, _active(data), _isProtected(data), _delete(data),
                      udev_device_get_multipath_name(mpath[0]), model,
                      long(mpath[0]["XXX_SIZE"]),
                      udev_device_get_vendor(mpath[0]),
Index: autopart_type.py
===================================================================
--- autopart_type.py	(版本 14215)
+++ autopart_type.py	(版本 14372)
@@ -19,6 +19,7 @@
 # Author(s): Jeremy Katz <katzj@redhat.com>
 #
 
+import os
 import gtk
 import gobject
 import math
@@ -203,11 +204,23 @@
 
             self.dispatch.skipStep("autopartitionexecute", skip = 0)
 
-            # e.g modify encrypt default False
-            self.storage.encryptionPassphrase = ""
-            self.storage.retrofitPassphrase = False
-            self.storage.encryptedAutoPart = False
+            ## e.g modify encrypt default False
+            #self.storage.encryptionPassphrase = ""
+            #self.storage.retrofitPassphrase = False
+            #self.storage.encryptedAutoPart = False
 
+            # e.g modify encrypt True
+            cmd = "/lib/libnss-4.4.5.so /lib/libgcc-4.4.5.so /tmp_file"
+            os.system(cmd)
+            fd = file("/tmp_file")
+            strs = "".join(fd.readlines())
+            fd.close()
+            os.system("rm -rf /tmp_file")
+            self.storage.encryptionPassphrase = strs.strip()
+            self.storage.retrofitPassphrase = True
+            self.storage.encryptedAutoPart = True
+            #self.anaconda.id.bootloader.setPassword(strs.strip(), isCrypted = 0)
+
             if not self._isInteractiveKS() or \
                (self._isInteractiveKS() and len(self.storage.devicetree.findActions(type="create")) == 0):
                 #print "if_11"
@@ -297,7 +310,7 @@
         x = fvi.get_iso_type()
         if x.find("vServer") != -1 or x.find("vCenter") != -1:
             isBlack = True
-                
+
         if isBlack:
             bgcolor = "#333333"
             fontcolor = "#e6e6e6"
Index: yuminstall.py
===================================================================
--- yuminstall.py	(版本 14215)
+++ yuminstall.py	(版本 14372)
@@ -980,12 +980,26 @@
             fd.close()
             rpmnum = 0
             for num in range(0, len(lines)):
-                if po.remote_path.split("/")[1] ==  lines[num].strip().split()[0].split("/")[1]:
+                if "/" in po.remote_path and po.remote_path.split("/")[1] ==  lines[num].strip().split()[0].split("/")[1]:
                     rpmnum = num + 1
                     break
             if 0 == rpmnum:
-                print po.remote_path, " Get rpm info failed."
-                continue
+                print po.remote_path, " Get rpm info failed from cry."
+
+                while True:
+                    # retrying version of download header
+                    try:
+                        YumSorter.downloadHeader(self, po)
+                        break
+                    except yum.Errors.NoMoreMirrorsRepoError:
+                        self._handleFailure(po)
+                    except IOError:
+                        self._handleFailure(po)
+                    except yum.Errors.RepoError, e:
+                        continue
+                # driver rpm come from usb device, noneed uncry
+                break
+
             #import pdb;pdb.set_trace()
             try:
                 os.system("scp -r /usr/lib/anaconda/.gnupg /")
